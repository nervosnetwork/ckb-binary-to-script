// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod ckb {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
pub mod protocol {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum SyncPayload {
  NONE = 0,
  GetHeaders = 1,
  Headers = 2,
  GetBlocks = 3,
  Block = 4,

}

const ENUM_MIN_SYNC_PAYLOAD: u8 = 0;
const ENUM_MAX_SYNC_PAYLOAD: u8 = 4;

impl<'a> flatbuffers::Follow<'a> for SyncPayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for SyncPayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const SyncPayload;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const SyncPayload;
    unsafe { *p }
  }
}

impl flatbuffers::Push for SyncPayload {
    type Output = SyncPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<SyncPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SYNC_PAYLOAD:[SyncPayload; 5] = [
  SyncPayload::NONE,
  SyncPayload::GetHeaders,
  SyncPayload::Headers,
  SyncPayload::GetBlocks,
  SyncPayload::Block
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SYNC_PAYLOAD:[&'static str; 5] = [
    "NONE",
    "GetHeaders",
    "Headers",
    "GetBlocks",
    "Block"
];

pub fn enum_name_sync_payload(e: SyncPayload) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_SYNC_PAYLOAD[index]
}

pub struct SyncPayloadUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum RelayPayload {
  NONE = 0,
  CompactBlock = 1,
  Transaction = 2,
  GetBlockTransactions = 3,
  BlockTransactions = 4,
  GetBlockProposal = 5,
  BlockProposal = 6,

}

const ENUM_MIN_RELAY_PAYLOAD: u8 = 0;
const ENUM_MAX_RELAY_PAYLOAD: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for RelayPayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for RelayPayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const RelayPayload;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const RelayPayload;
    unsafe { *p }
  }
}

impl flatbuffers::Push for RelayPayload {
    type Output = RelayPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<RelayPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_RELAY_PAYLOAD:[RelayPayload; 7] = [
  RelayPayload::NONE,
  RelayPayload::CompactBlock,
  RelayPayload::Transaction,
  RelayPayload::GetBlockTransactions,
  RelayPayload::BlockTransactions,
  RelayPayload::GetBlockProposal,
  RelayPayload::BlockProposal
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_RELAY_PAYLOAD:[&'static str; 7] = [
    "NONE",
    "CompactBlock",
    "Transaction",
    "GetBlockTransactions",
    "BlockTransactions",
    "GetBlockProposal",
    "BlockProposal"
];

pub fn enum_name_relay_payload(e: RelayPayload) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_RELAY_PAYLOAD[index]
}

pub struct RelayPayloadUnionTableOffset {}
pub enum SyncMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SyncMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SyncMessage<'a> {
    type Inner = SyncMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SyncMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SyncMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SyncMessageArgs) -> flatbuffers::WIPOffset<SyncMessage<'bldr>> {
      let mut builder = SyncMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn payload_type(&self) -> SyncPayload {
    self._tab.get::<SyncPayload>(SyncMessage::VT_PAYLOAD_TYPE, Some(SyncPayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SyncMessage::VT_PAYLOAD, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_headers(&'a self) -> Option<GetHeaders> {
    if self.payload_type() == SyncPayload::GetHeaders {
      self.payload().map(|u| GetHeaders::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_headers(&'a self) -> Option<Headers> {
    if self.payload_type() == SyncPayload::Headers {
      self.payload().map(|u| Headers::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_blocks(&'a self) -> Option<GetBlocks> {
    if self.payload_type() == SyncPayload::GetBlocks {
      self.payload().map(|u| GetBlocks::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_block(&'a self) -> Option<Block> {
    if self.payload_type() == SyncPayload::Block {
      self.payload().map(|u| Block::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct SyncMessageArgs {
    pub payload_type: SyncPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SyncMessageArgs {
    #[inline]
    fn default() -> Self {
        SyncMessageArgs {
            payload_type: SyncPayload::NONE,
            payload: None,
        }
    }
}
pub struct SyncMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SyncMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: SyncPayload) {
    self.fbb_.push_slot::<SyncPayload>(SyncMessage::VT_PAYLOAD_TYPE, payload_type, SyncPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SyncMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SyncMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SyncMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SyncMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BytesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Bytes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bytes<'a> {
    type Inner = Bytes<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Bytes<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bytes {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BytesArgs<'args>) -> flatbuffers::WIPOffset<Bytes<'bldr>> {
      let mut builder = BytesBuilder::new(_fbb);
      if let Some(x) = args.seq { builder.add_seq(x); }
      builder.finish()
    }

    pub const VT_SEQ: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn seq(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Bytes::VT_SEQ, None).map(|v| v.safe_slice())
  }
}

pub struct BytesArgs<'a> {
    pub seq: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for BytesArgs<'a> {
    #[inline]
    fn default() -> Self {
        BytesArgs {
            seq: None,
        }
    }
}
pub struct BytesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BytesBuilder<'a, 'b> {
  #[inline]
  pub fn add_seq(&mut self, seq: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bytes::VT_SEQ, seq);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BytesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BytesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bytes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetHeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetHeaders<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetHeaders<'a> {
    type Inner = GetHeaders<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetHeaders<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetHeaders {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetHeadersArgs<'args>) -> flatbuffers::WIPOffset<GetHeaders<'bldr>> {
      let mut builder = GetHeadersBuilder::new(_fbb);
      if let Some(x) = args.hash_stop { builder.add_hash_stop(x); }
      if let Some(x) = args.block_locator_hashes { builder.add_block_locator_hashes(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_LOCATOR_HASHES: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_STOP: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(GetHeaders::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn block_locator_hashes(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(GetHeaders::VT_BLOCK_LOCATOR_HASHES, None)
  }
  #[inline]
  pub fn hash_stop(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(GetHeaders::VT_HASH_STOP, None)
  }
}

pub struct GetHeadersArgs<'a> {
    pub version: u32,
    pub block_locator_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
    pub hash_stop: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
}
impl<'a> Default for GetHeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetHeadersArgs {
            version: 0,
            block_locator_hashes: None,
            hash_stop: None,
        }
    }
}
pub struct GetHeadersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetHeadersBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(GetHeaders::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_block_locator_hashes(&mut self, block_locator_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetHeaders::VT_BLOCK_LOCATOR_HASHES, block_locator_hashes);
  }
  #[inline]
  pub fn add_hash_stop(&mut self, hash_stop: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(GetHeaders::VT_HASH_STOP, hash_stop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetHeadersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetHeadersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetHeaders<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetBlocksOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetBlocks<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlocks<'a> {
    type Inner = GetBlocks<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetBlocks<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetBlocks {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetBlocksArgs<'args>) -> flatbuffers::WIPOffset<GetBlocks<'bldr>> {
      let mut builder = GetBlocksBuilder::new(_fbb);
      if let Some(x) = args.block_hashes { builder.add_block_hashes(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HASHES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn block_hashes(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(GetBlocks::VT_BLOCK_HASHES, None)
  }
}

pub struct GetBlocksArgs<'a> {
    pub block_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
}
impl<'a> Default for GetBlocksArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetBlocksArgs {
            block_hashes: None,
        }
    }
}
pub struct GetBlocksBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlocksBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hashes(&mut self, block_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlocks::VT_BLOCK_HASHES, block_hashes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlocksBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlocksBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlocks<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Headers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Headers<'a> {
    type Inner = Headers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Headers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Headers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeadersArgs<'args>) -> flatbuffers::WIPOffset<Headers<'bldr>> {
      let mut builder = HeadersBuilder::new(_fbb);
      if let Some(x) = args.headers { builder.add_headers(x); }
      builder.finish()
    }

    pub const VT_HEADERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Header<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Header<'a>>>>>(Headers::VT_HEADERS, None)
  }
}

pub struct HeadersArgs<'a> {
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Header<'a >>>>>,
}
impl<'a> Default for HeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeadersArgs {
            headers: None,
        }
    }
}
pub struct HeadersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeadersBuilder<'a, 'b> {
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Header<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Headers::VT_HEADERS, headers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeadersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeadersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Headers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Header<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeaderArgs<'args>) -> flatbuffers::WIPOffset<Header<'bldr>> {
      let mut builder = HeaderBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.add_number(args.number);
      builder.add_timestamp(args.timestamp);
      builder.add_uncles_count(args.uncles_count);
      if let Some(x) = args.uncles_hash { builder.add_uncles_hash(x); }
      if let Some(x) = args.cellbase_id { builder.add_cellbase_id(x); }
      if let Some(x) = args.proof { builder.add_proof(x); }
      if let Some(x) = args.difficulty { builder.add_difficulty(x); }
      if let Some(x) = args.txs_proposal { builder.add_txs_proposal(x); }
      if let Some(x) = args.txs_commit { builder.add_txs_commit(x); }
      if let Some(x) = args.parent_hash { builder.add_parent_hash(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
    pub const VT_NUMBER: flatbuffers::VOffsetT = 10;
    pub const VT_TXS_COMMIT: flatbuffers::VOffsetT = 12;
    pub const VT_TXS_PROPOSAL: flatbuffers::VOffsetT = 14;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 16;
    pub const VT_NONCE: flatbuffers::VOffsetT = 18;
    pub const VT_PROOF: flatbuffers::VOffsetT = 20;
    pub const VT_CELLBASE_ID: flatbuffers::VOffsetT = 22;
    pub const VT_UNCLES_HASH: flatbuffers::VOffsetT = 24;
    pub const VT_UNCLES_COUNT: flatbuffers::VOffsetT = 26;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Header::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn parent_hash(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_PARENT_HASH, None)
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_TIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn number(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_NUMBER, Some(0)).unwrap()
  }
  #[inline]
  pub fn txs_commit(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_TXS_COMMIT, None)
  }
  #[inline]
  pub fn txs_proposal(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_TXS_PROPOSAL, None)
  }
  #[inline]
  pub fn difficulty(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_DIFFICULTY, None)
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_NONCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn proof(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_PROOF, None)
  }
  #[inline]
  pub fn cellbase_id(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_CELLBASE_ID, None)
  }
  #[inline]
  pub fn uncles_hash(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_UNCLES_HASH, None)
  }
  #[inline]
  pub fn uncles_count(&self) -> u32 {
    self._tab.get::<u32>(Header::VT_UNCLES_COUNT, Some(0)).unwrap()
  }
}

pub struct HeaderArgs<'a> {
    pub version: u32,
    pub parent_hash: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub timestamp: u64,
    pub number: u64,
    pub txs_commit: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub txs_proposal: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub difficulty: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub nonce: u64,
    pub proof: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub cellbase_id: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub uncles_hash: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub uncles_count: u32,
}
impl<'a> Default for HeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            version: 0,
            parent_hash: None,
            timestamp: 0,
            number: 0,
            txs_commit: None,
            txs_proposal: None,
            difficulty: None,
            nonce: 0,
            proof: None,
            cellbase_id: None,
            uncles_hash: None,
            uncles_count: 0,
        }
    }
}
pub struct HeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_parent_hash(&mut self, parent_hash: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_PARENT_HASH, parent_hash);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_number(&mut self, number: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_NUMBER, number, 0);
  }
  #[inline]
  pub fn add_txs_commit(&mut self, txs_commit: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_TXS_COMMIT, txs_commit);
  }
  #[inline]
  pub fn add_txs_proposal(&mut self, txs_proposal: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_TXS_PROPOSAL, txs_proposal);
  }
  #[inline]
  pub fn add_difficulty(&mut self, difficulty: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_DIFFICULTY, difficulty);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_PROOF, proof);
  }
  #[inline]
  pub fn add_cellbase_id(&mut self, cellbase_id: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_CELLBASE_ID, cellbase_id);
  }
  #[inline]
  pub fn add_uncles_hash(&mut self, uncles_hash: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_UNCLES_HASH, uncles_hash);
  }
  #[inline]
  pub fn add_uncles_count(&mut self, uncles_count: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_UNCLES_COUNT, uncles_count, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>) -> flatbuffers::WIPOffset<Block<'bldr>> {
      let mut builder = BlockBuilder::new(_fbb);
      if let Some(x) = args.proposal_transactions { builder.add_proposal_transactions(x); }
      if let Some(x) = args.commit_transactions { builder.add_commit_transactions(x); }
      if let Some(x) = args.uncles { builder.add_uncles(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_UNCLES: flatbuffers::VOffsetT = 6;
    pub const VT_COMMIT_TRANSACTIONS: flatbuffers::VOffsetT = 8;
    pub const VT_PROPOSAL_TRANSACTIONS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Block::VT_HEADER, None)
  }
  #[inline]
  pub fn uncles(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>>>(Block::VT_UNCLES, None)
  }
  #[inline]
  pub fn commit_transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(Block::VT_COMMIT_TRANSACTIONS, None)
  }
  #[inline]
  pub fn proposal_transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(Block::VT_PROPOSAL_TRANSACTIONS, None)
  }
}

pub struct BlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub uncles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<UncleBlock<'a >>>>>,
    pub commit_transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
    pub proposal_transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            header: None,
            uncles: None,
            commit_transactions: None,
            proposal_transactions: None,
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Block::VT_HEADER, header);
  }
  #[inline]
  pub fn add_uncles(&mut self, uncles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UncleBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_UNCLES, uncles);
  }
  #[inline]
  pub fn add_commit_transactions(&mut self, commit_transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_COMMIT_TRANSACTIONS, commit_transactions);
  }
  #[inline]
  pub fn add_proposal_transactions(&mut self, proposal_transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_PROPOSAL_TRANSACTIONS, proposal_transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UncleBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UncleBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UncleBlock<'a> {
    type Inner = UncleBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UncleBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UncleBlock {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UncleBlockArgs<'args>) -> flatbuffers::WIPOffset<UncleBlock<'bldr>> {
      let mut builder = UncleBlockBuilder::new(_fbb);
      if let Some(x) = args.proposal_transactions { builder.add_proposal_transactions(x); }
      if let Some(x) = args.cellbase { builder.add_cellbase(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_CELLBASE: flatbuffers::VOffsetT = 6;
    pub const VT_PROPOSAL_TRANSACTIONS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(UncleBlock::VT_HEADER, None)
  }
  #[inline]
  pub fn cellbase(&self) -> Option<Transaction<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Transaction<'a>>>(UncleBlock::VT_CELLBASE, None)
  }
  #[inline]
  pub fn proposal_transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(UncleBlock::VT_PROPOSAL_TRANSACTIONS, None)
  }
}

pub struct UncleBlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub cellbase: Option<flatbuffers::WIPOffset<Transaction<'a >>>,
    pub proposal_transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
}
impl<'a> Default for UncleBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        UncleBlockArgs {
            header: None,
            cellbase: None,
            proposal_transactions: None,
        }
    }
}
pub struct UncleBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UncleBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(UncleBlock::VT_HEADER, header);
  }
  #[inline]
  pub fn add_cellbase(&mut self, cellbase: flatbuffers::WIPOffset<Transaction<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Transaction>>(UncleBlock::VT_CELLBASE, cellbase);
  }
  #[inline]
  pub fn add_proposal_transactions(&mut self, proposal_transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UncleBlock::VT_PROPOSAL_TRANSACTIONS, proposal_transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UncleBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UncleBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UncleBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Transaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
    type Inner = Transaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Transaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Transaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransactionArgs<'args>) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
      let mut builder = TransactionBuilder::new(_fbb);
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      if let Some(x) = args.deps { builder.add_deps(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_DEPS: flatbuffers::VOffsetT = 6;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Transaction::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn deps(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<OutPoint<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<OutPoint<'a>>>>>(Transaction::VT_DEPS, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellInput<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellInput<'a>>>>>(Transaction::VT_INPUTS, None)
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellOutput<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellOutput<'a>>>>>(Transaction::VT_OUTPUTS, None)
  }
}

pub struct TransactionArgs<'a> {
    pub version: u32,
    pub deps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<OutPoint<'a >>>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CellInput<'a >>>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CellOutput<'a >>>>>,
}
impl<'a> Default for TransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransactionArgs {
            version: 0,
            deps: None,
            inputs: None,
            outputs: None,
        }
    }
}
pub struct TransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Transaction::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_deps(&mut self, deps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OutPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_DEPS, deps);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CellInput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CellOutput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OutPointOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OutPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutPoint<'a> {
    type Inner = OutPoint<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OutPoint<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OutPoint {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OutPointArgs<'args>) -> flatbuffers::WIPOffset<OutPoint<'bldr>> {
      let mut builder = OutPointBuilder::new(_fbb);
      builder.add_index(args.index);
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn hash(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(OutPoint::VT_HASH, None)
  }
  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(OutPoint::VT_INDEX, Some(0)).unwrap()
  }
}

pub struct OutPointArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub index: u32,
}
impl<'a> Default for OutPointArgs<'a> {
    #[inline]
    fn default() -> Self {
        OutPointArgs {
            hash: None,
            index: 0,
        }
    }
}
pub struct OutPointBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutPointBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(OutPoint::VT_HASH, hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(OutPoint::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutPointBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CellInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellInput<'a> {
    type Inner = CellInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellInputArgs<'args>) -> flatbuffers::WIPOffset<CellInput<'bldr>> {
      let mut builder = CellInputBuilder::new(_fbb);
      if let Some(x) = args.unlock { builder.add_unlock(x); }
      builder.add_index(args.index);
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEX: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCK: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn hash(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(CellInput::VT_HASH, None)
  }
  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(CellInput::VT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn unlock(&self) -> Option<Script<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Script<'a>>>(CellInput::VT_UNLOCK, None)
  }
}

pub struct CellInputArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub index: u32,
    pub unlock: Option<flatbuffers::WIPOffset<Script<'a >>>,
}
impl<'a> Default for CellInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellInputArgs {
            hash: None,
            index: 0,
            unlock: None,
        }
    }
}
pub struct CellInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(CellInput::VT_HASH, hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(CellInput::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_unlock(&mut self, unlock: flatbuffers::WIPOffset<Script<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Script>>(CellInput::VT_UNLOCK, unlock);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CellInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CellInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CellOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellOutput<'a> {
    type Inner = CellOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellOutputArgs<'args>) -> flatbuffers::WIPOffset<CellOutput<'bldr>> {
      let mut builder = CellOutputBuilder::new(_fbb);
      builder.add_capacity(args.capacity);
      if let Some(x) = args.contract { builder.add_contract(x); }
      if let Some(x) = args.lock { builder.add_lock(x); }
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_CAPACITY: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;
    pub const VT_LOCK: flatbuffers::VOffsetT = 8;
    pub const VT_CONTRACT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn capacity(&self) -> u64 {
    self._tab.get::<u64>(CellOutput::VT_CAPACITY, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(CellOutput::VT_DATA, None)
  }
  #[inline]
  pub fn lock(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(CellOutput::VT_LOCK, None)
  }
  #[inline]
  pub fn contract(&self) -> Option<Script<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Script<'a>>>(CellOutput::VT_CONTRACT, None)
  }
}

pub struct CellOutputArgs<'a> {
    pub capacity: u64,
    pub data: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub lock: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub contract: Option<flatbuffers::WIPOffset<Script<'a >>>,
}
impl<'a> Default for CellOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellOutputArgs {
            capacity: 0,
            data: None,
            lock: None,
            contract: None,
        }
    }
}
pub struct CellOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_capacity(&mut self, capacity: u64) {
    self.fbb_.push_slot::<u64>(CellOutput::VT_CAPACITY, capacity, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(CellOutput::VT_DATA, data);
  }
  #[inline]
  pub fn add_lock(&mut self, lock: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(CellOutput::VT_LOCK, lock);
  }
  #[inline]
  pub fn add_contract(&mut self, contract: flatbuffers::WIPOffset<Script<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Script>>(CellOutput::VT_CONTRACT, contract);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CellOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CellOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ScriptOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Script<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Script<'a> {
    type Inner = Script<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Script<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Script {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ScriptArgs<'args>) -> flatbuffers::WIPOffset<Script<'bldr>> {
      let mut builder = ScriptBuilder::new(_fbb);
      if let Some(x) = args.signed_args { builder.add_signed_args(x); }
      if let Some(x) = args.reference { builder.add_reference(x); }
      if let Some(x) = args.binary { builder.add_binary(x); }
      if let Some(x) = args.args { builder.add_args(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_ARGS: flatbuffers::VOffsetT = 6;
    pub const VT_BINARY: flatbuffers::VOffsetT = 8;
    pub const VT_REFERENCE: flatbuffers::VOffsetT = 10;
    pub const VT_SIGNED_ARGS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn version(&self) -> u8 {
    self._tab.get::<u8>(Script::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn args(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(Script::VT_ARGS, None)
  }
  #[inline]
  pub fn binary(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Script::VT_BINARY, None)
  }
  #[inline]
  pub fn reference(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Script::VT_REFERENCE, None)
  }
  #[inline]
  pub fn signed_args(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(Script::VT_SIGNED_ARGS, None)
  }
}

pub struct ScriptArgs<'a> {
    pub version: u8,
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
    pub binary: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub reference: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub signed_args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
}
impl<'a> Default for ScriptArgs<'a> {
    #[inline]
    fn default() -> Self {
        ScriptArgs {
            version: 0,
            args: None,
            binary: None,
            reference: None,
            signed_args: None,
        }
    }
}
pub struct ScriptBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScriptBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u8) {
    self.fbb_.push_slot::<u8>(Script::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Script::VT_ARGS, args);
  }
  #[inline]
  pub fn add_binary(&mut self, binary: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Script::VT_BINARY, binary);
  }
  #[inline]
  pub fn add_reference(&mut self, reference: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Script::VT_REFERENCE, reference);
  }
  #[inline]
  pub fn add_signed_args(&mut self, signed_args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Script::VT_SIGNED_ARGS, signed_args);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScriptBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScriptBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Script<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RelayMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RelayMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayMessage<'a> {
    type Inner = RelayMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RelayMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RelayMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelayMessageArgs) -> flatbuffers::WIPOffset<RelayMessage<'bldr>> {
      let mut builder = RelayMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn payload_type(&self) -> RelayPayload {
    self._tab.get::<RelayPayload>(RelayMessage::VT_PAYLOAD_TYPE, Some(RelayPayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RelayMessage::VT_PAYLOAD, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_compact_block(&'a self) -> Option<CompactBlock> {
    if self.payload_type() == RelayPayload::CompactBlock {
      self.payload().map(|u| CompactBlock::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_transaction(&'a self) -> Option<Transaction> {
    if self.payload_type() == RelayPayload::Transaction {
      self.payload().map(|u| Transaction::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_block_transactions(&'a self) -> Option<GetBlockTransactions> {
    if self.payload_type() == RelayPayload::GetBlockTransactions {
      self.payload().map(|u| GetBlockTransactions::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_block_transactions(&'a self) -> Option<BlockTransactions> {
    if self.payload_type() == RelayPayload::BlockTransactions {
      self.payload().map(|u| BlockTransactions::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_block_proposal(&'a self) -> Option<GetBlockProposal> {
    if self.payload_type() == RelayPayload::GetBlockProposal {
      self.payload().map(|u| GetBlockProposal::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_block_proposal(&'a self) -> Option<BlockProposal> {
    if self.payload_type() == RelayPayload::BlockProposal {
      self.payload().map(|u| BlockProposal::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct RelayMessageArgs {
    pub payload_type: RelayPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RelayMessageArgs {
    #[inline]
    fn default() -> Self {
        RelayMessageArgs {
            payload_type: RelayPayload::NONE,
            payload: None,
        }
    }
}
pub struct RelayMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelayMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: RelayPayload) {
    self.fbb_.push_slot::<RelayPayload>(RelayMessage::VT_PAYLOAD_TYPE, payload_type, RelayPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelayMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelayMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CompactBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CompactBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompactBlock<'a> {
    type Inner = CompactBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CompactBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CompactBlock {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CompactBlockArgs<'args>) -> flatbuffers::WIPOffset<CompactBlock<'bldr>> {
      let mut builder = CompactBlockBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      if let Some(x) = args.proposal_transactions { builder.add_proposal_transactions(x); }
      if let Some(x) = args.uncles { builder.add_uncles(x); }
      if let Some(x) = args.prefilled_transactions { builder.add_prefilled_transactions(x); }
      if let Some(x) = args.short_ids { builder.add_short_ids(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_NONCE: flatbuffers::VOffsetT = 6;
    pub const VT_SHORT_IDS: flatbuffers::VOffsetT = 8;
    pub const VT_PREFILLED_TRANSACTIONS: flatbuffers::VOffsetT = 10;
    pub const VT_UNCLES: flatbuffers::VOffsetT = 12;
    pub const VT_PROPOSAL_TRANSACTIONS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(CompactBlock::VT_HEADER, None)
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(CompactBlock::VT_NONCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn short_ids(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(CompactBlock::VT_SHORT_IDS, None)
  }
  #[inline]
  pub fn prefilled_transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<PrefilledTransaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<PrefilledTransaction<'a>>>>>(CompactBlock::VT_PREFILLED_TRANSACTIONS, None)
  }
  #[inline]
  pub fn uncles(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>>>(CompactBlock::VT_UNCLES, None)
  }
  #[inline]
  pub fn proposal_transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(CompactBlock::VT_PROPOSAL_TRANSACTIONS, None)
  }
}

pub struct CompactBlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub nonce: u64,
    pub short_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
    pub prefilled_transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<PrefilledTransaction<'a >>>>>,
    pub uncles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<UncleBlock<'a >>>>>,
    pub proposal_transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
}
impl<'a> Default for CompactBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        CompactBlockArgs {
            header: None,
            nonce: 0,
            short_ids: None,
            prefilled_transactions: None,
            uncles: None,
            proposal_transactions: None,
        }
    }
}
pub struct CompactBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CompactBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(CompactBlock::VT_HEADER, header);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(CompactBlock::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn add_short_ids(&mut self, short_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_SHORT_IDS, short_ids);
  }
  #[inline]
  pub fn add_prefilled_transactions(&mut self, prefilled_transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PrefilledTransaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_PREFILLED_TRANSACTIONS, prefilled_transactions);
  }
  #[inline]
  pub fn add_uncles(&mut self, uncles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UncleBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_UNCLES, uncles);
  }
  #[inline]
  pub fn add_proposal_transactions(&mut self, proposal_transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_PROPOSAL_TRANSACTIONS, proposal_transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CompactBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CompactBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompactBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PrefilledTransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PrefilledTransaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrefilledTransaction<'a> {
    type Inner = PrefilledTransaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PrefilledTransaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrefilledTransaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrefilledTransactionArgs<'args>) -> flatbuffers::WIPOffset<PrefilledTransaction<'bldr>> {
      let mut builder = PrefilledTransactionBuilder::new(_fbb);
      if let Some(x) = args.transaction { builder.add_transaction(x); }
      builder.add_index(args.index);
      builder.finish()
    }

    pub const VT_INDEX: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSACTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(PrefilledTransaction::VT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn transaction(&self) -> Option<Transaction<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Transaction<'a>>>(PrefilledTransaction::VT_TRANSACTION, None)
  }
}

pub struct PrefilledTransactionArgs<'a> {
    pub index: u32,
    pub transaction: Option<flatbuffers::WIPOffset<Transaction<'a >>>,
}
impl<'a> Default for PrefilledTransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrefilledTransactionArgs {
            index: 0,
            transaction: None,
        }
    }
}
pub struct PrefilledTransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrefilledTransactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(PrefilledTransaction::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<Transaction<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Transaction>>(PrefilledTransaction::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrefilledTransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PrefilledTransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrefilledTransaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetBlockTransactionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetBlockTransactions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockTransactions<'a> {
    type Inner = GetBlockTransactions<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetBlockTransactions<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetBlockTransactions {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetBlockTransactionsArgs<'args>) -> flatbuffers::WIPOffset<GetBlockTransactions<'bldr>> {
      let mut builder = GetBlockTransactionsBuilder::new(_fbb);
      if let Some(x) = args.indexes { builder.add_indexes(x); }
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEXES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn hash(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(GetBlockTransactions::VT_HASH, None)
  }
  #[inline]
  pub fn indexes(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(GetBlockTransactions::VT_INDEXES, None)
  }
}

pub struct GetBlockTransactionsArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub indexes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
}
impl<'a> Default for GetBlockTransactionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetBlockTransactionsArgs {
            hash: None,
            indexes: None,
        }
    }
}
pub struct GetBlockTransactionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockTransactionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(GetBlockTransactions::VT_HASH, hash);
  }
  #[inline]
  pub fn add_indexes(&mut self, indexes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlockTransactions::VT_INDEXES, indexes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockTransactionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockTransactionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockTransactions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockTransactionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockTransactions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockTransactions<'a> {
    type Inner = BlockTransactions<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockTransactions<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockTransactions {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockTransactionsArgs<'args>) -> flatbuffers::WIPOffset<BlockTransactions<'bldr>> {
      let mut builder = BlockTransactionsBuilder::new(_fbb);
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn hash(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(BlockTransactions::VT_HASH, None)
  }
  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(BlockTransactions::VT_TRANSACTIONS, None)
  }
}

pub struct BlockTransactionsArgs<'a> {
    pub hash: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
}
impl<'a> Default for BlockTransactionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockTransactionsArgs {
            hash: None,
            transactions: None,
        }
    }
}
pub struct BlockTransactionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockTransactionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(BlockTransactions::VT_HASH, hash);
  }
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockTransactions::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockTransactionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockTransactionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockTransactions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetBlockProposalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetBlockProposal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockProposal<'a> {
    type Inner = GetBlockProposal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetBlockProposal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetBlockProposal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetBlockProposalArgs<'args>) -> flatbuffers::WIPOffset<GetBlockProposal<'bldr>> {
      let mut builder = GetBlockProposalBuilder::new(_fbb);
      builder.add_block_number(args.block_number);
      if let Some(x) = args.proposal_transactions { builder.add_proposal_transactions(x); }
      builder.finish()
    }

    pub const VT_BLOCK_NUMBER: flatbuffers::VOffsetT = 4;
    pub const VT_PROPOSAL_TRANSACTIONS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn block_number(&self) -> u64 {
    self._tab.get::<u64>(GetBlockProposal::VT_BLOCK_NUMBER, Some(0)).unwrap()
  }
  #[inline]
  pub fn proposal_transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(GetBlockProposal::VT_PROPOSAL_TRANSACTIONS, None)
  }
}

pub struct GetBlockProposalArgs<'a> {
    pub block_number: u64,
    pub proposal_transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
}
impl<'a> Default for GetBlockProposalArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetBlockProposalArgs {
            block_number: 0,
            proposal_transactions: None,
        }
    }
}
pub struct GetBlockProposalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockProposalBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_number(&mut self, block_number: u64) {
    self.fbb_.push_slot::<u64>(GetBlockProposal::VT_BLOCK_NUMBER, block_number, 0);
  }
  #[inline]
  pub fn add_proposal_transactions(&mut self, proposal_transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlockProposal::VT_PROPOSAL_TRANSACTIONS, proposal_transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockProposalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockProposalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockProposal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockProposalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockProposal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockProposal<'a> {
    type Inner = BlockProposal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockProposal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockProposal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockProposalArgs<'args>) -> flatbuffers::WIPOffset<BlockProposal<'bldr>> {
      let mut builder = BlockProposalBuilder::new(_fbb);
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      builder.finish()
    }

    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(BlockProposal::VT_TRANSACTIONS, None)
  }
}

pub struct BlockProposalArgs<'a> {
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
}
impl<'a> Default for BlockProposalArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockProposalArgs {
            transactions: None,
        }
    }
}
pub struct BlockProposalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockProposalBuilder<'a, 'b> {
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockProposal::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockProposalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockProposalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockProposal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_sync_message<'a>(buf: &'a [u8]) -> SyncMessage<'a> {
  flatbuffers::get_root::<SyncMessage<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_sync_message<'a>(buf: &'a [u8]) -> SyncMessage<'a> {
  flatbuffers::get_size_prefixed_root::<SyncMessage<'a>>(buf)
}

#[inline]
pub fn finish_sync_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<SyncMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_sync_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<SyncMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Protocol
}  // pub mod Ckb

